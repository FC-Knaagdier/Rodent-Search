<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Zoek</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; max-width: 900px; margin: 2rem auto; padding: 0 1rem; color: #111; }
    header { margin-bottom: 1rem; }
    input#q { width: 100%; padding: 0.6rem; font-size: 1rem; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; }
    .meta { color: #666; font-size: 0.9rem; margin-top: 0.25rem; }
    #results { margin-top: 1rem; }
    .result { padding: 0.75rem 0; border-bottom: 1px solid #eee; }
    .title { font-weight: 600; margin-bottom: 0.25rem; }
    .desc { color: #444; }
    .score { float: right; color: #888; font-size: 0.9rem; }
    .no-results { color: #666; padding: 1rem 0; }
    @media (prefers-color-scheme: dark) {
      body { background: #0b0b0b; color: #ddd; }
      input#q { background: #111; border-color: #222; color: #ddd; }
      .result { border-bottom-color: #222; }
      .desc { color: #bbb; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Zoek</h1>
    <div class="meta">Zoekt op Titel &amp; Beschrijving â€” privacyvriendelijk, alles in je browser</div>
  </header>

  <main>
    <input id="q" placeholder="Zoek op titel of beschrijving..." autocomplete="off" />
    <div id="results" aria-live="polite"></div>
  </main>

  <script>
  // Minimal client-side search (geen externe libs)
  // Verwacht: public/index.json en public/docs.json bestaan en zijn gemaakt door het build-script.

  // Normalisatie en tokenization
  function normalizeText(s) {
    return String(s || '')
      .toLowerCase()
      .replace(/[^a-z0-9\u00C0-\u017F\s]/gi, ' ')
      .replace(/\s+/g, ' ')
      .trim();
  }
  function tokenize(s) {
    return normalizeText(s).split(' ').filter(Boolean);
  }

  // HTML-escape om XSS te voorkomen
  function escapeHtml(s) {
    return String(s || '').replace(/[&<>"']/g, (c) => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[c]));
  }

  async function initSearch() {
    // Laad statische index en docs (zorg dat deze bestanden publiekelijk beschikbaar zijn)
    const [idxResp, docsResp] = await Promise.all([fetch('/index.json'), fetch('/docs.json')]);
    if (!idxResp.ok || !docsResp.ok) {
      document.getElementById('results').innerText = 'Kon indexbestanden niet laden. Controleer dat /index.json en /docs.json bestaan.';
      return;
    }
    const index = await idxResp.json(); // { term: { df, postings: [[docId, freq], ...] }, ... }
    const docs = await docsResp.json();  // [{ id, title, description, url }, ...]
    const docsById = Object.fromEntries(docs.map(d => [d.id, d]));

    const N = docs.length;
    const idfCache = {};
    for (const term in index) {
      const df = index[term].df || (index[term].postings && index[term].postings.length) || 0;
      // eenvoudige IDF: log(1 + N/(1+df))
      idfCache[term] = Math.log(1 + N / (1 + df));
    }

    const qEl = document.getElementById('q');
    const resEl = document.getElementById('results');

    // Debounce input voor responsiviteit
    let timer = null;
    qEl.addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => performSearch(qEl.value.trim(), index, idfCache, docsById, resEl), 150);
    });

    // Optional: handle Enter for accessibility (execute immediately)
    qEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        clearTimeout(timer);
        performSearch(qEl.value.trim(), index, idfCache, docsById, resEl);
      }
    });
  }

  function performSearch(query, index, idfCache, docsById, resEl) {
    if (!query) {
      resEl.innerHTML = '';
      return;
    }
    const terms = tokenize(query);
    if (terms.length === 0) {
      resEl.innerHTML = '';
      return;
    }

    // Accumulate scores: term freq * idf. Title boost is already reflected in frequencies used when building index.
    const scores = Object.create(null); // docId -> score
    for (const t of terms) {
      const entry = index[t];
      if (!entry) continue;
      const idf = idfCache[t] || 1;
      for (const posting of entry.postings) {
        const [docId, freq] = posting;
        scores[docId] = (scores[docId] || 0) + freq * idf;
      }
    }

    const hits = Object.entries(scores)
      .map(([docId, score]) => ({ doc: docsById[docId], score }))
      .filter(h => h.doc) // safety
      .sort((a, b) => b.score - a.score)
      .slice(0, 50);

    if (!hits.length) {
      resEl.innerHTML = '<div class="no-results">Geen resultaten</div>';
      return;
    }

    resEl.innerHTML = hits.map(h => {
      const d = h.doc;
      return [
        '<article class="result" role="article" aria-label="' + escapeHtml(d.title || d.url) + '">',
          '<div class="title"><a href="' + escapeHtml(d.url) + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(d.title || d.url) + '</a></div>',
          '<div class="desc">' + escapeHtml(d.description || '') + '</div>',
          '<div class="score">' + (Math.round(h.score * 100) / 100) + '</div>',
        '</article>'
      ].join('');
    }).join('');
  }

  // Start
  initSearch().catch(err => {
    console.error(err);
    document.getElementById('results').innerText = 'Fout bij initialisatie: ' + err;
  });
  </script>
</body>
</html>
